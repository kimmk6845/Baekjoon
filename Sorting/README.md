
# 정렬 알고리즘
## 비교기반 정렬 알고리즘
### 선택정렬(Selection Sort)
- 배열에서 가장 작은 원소를 찾아 첫 번째 원소와 교환하고 두 번째 작은 원소를 찾아 두 번째 원소와 교환하는 방식으로 전체를 정렬하는 알고리즘
- 전체 데이터(N)에 대해서 비교 횟수는 N(N-1)/2가 되고 시간 복잡도는 O(N2)이 되므로 입력 데이터의 수에 따라 시간이 오래 걸리는 알고리즘이고 [1,2’,2]와 같은 입력 배열을 정렬하면 [1,2,2’]와 같이 크기가 같음에도 상대적인 위치가 변경될 수 있다는 단점을 보유
- 하지만 비교 횟수는 많아도 교환 횟수는 적어 교환이 많이 발생해야 하는 상황에서 효율적이며 구현하기 쉽다는 장점을 가짐


<br>
### 버블정렬(Bubble Sort)
- 서로 인접한 두 원소를 비교해 루프가 한 번 반복되면 가장 큰 원소를 맨 뒤로 보내는 알고리즘
- 구현이 매우 간단한 장점이 있지만, 가장 큰 원소가 맨 앞에 있는 경우 뒤로 이동하기 위해서 모든 요소와 교환되어야 하는 구조를 가짐. 따라서 레코드의 크기가 큰 경우 매우 비효율적인 알고리즘으로 O(N2)의 시간 복잡도를 가짐
- 거의 정렬된(almost sorted) 데이터에 대해서는 효율이 좋음


<br>
### 삽입정렬(Insertion Sort)
- 버블정렬의 비교횟수를 효율적으로 줄이기 위해 고안된 알고리즘으로 앞에서부터 차례대로 뒷부분의 배열과 비교하며 적절한 위치에 삽입하는 알고리즘
- 교환이 아닌 이동을 하기 때문에 버블정렬보다 빠른 효과를 볼 수 있으며 almost sorted 데이터에 가장 좋음, 평균적으로 O(N^2)의 시간 복잡도를 가짐.


<br>
### 쉘정렬(Shell Sort)
- 삽입정렬을 보완한 알고리즘으로 멀리 떨어진 원소끼리 교환이 가능하도록 해 정렬 속도를 향상시킴. 전체를 여러 개의 부분 리스트로 만들어 각 부분 리스트를 삽입 정렬을 이용해 정렬시키고 모든 부분 리스트가 정렬되면 다시 전체를 더 적은 부분 리스트의 수로 만드는 방식으로 정렬함
- 삽입정렬보다 우수한 능력을 보이고 멀리 떨어진 원소간 여러 번 교환을 통해 정렬하던 버블정렬의 단점을 해결할 수 있음. 하지만 부분 리스트로 나눌 때 간격을 잘못 설정하면 성능이 매우 안좋아질 수 있음
- 평균적으로 O(NlogN)의 시간복잡도를 갖고 최악의 경우 O(N^4/3)이 됨


<br>
### 퀵정렬(Quick Sort)
- divide and conquer기법을 사용한 정렬 방법 중 하나로 피봇을 정해 두 개의 파티션으로 분할 후 왼쪽 파티션에서는 피봇보다 큰 원소가 존재하지 않도록, 오른쪽 파티션에는 피봇보다 작은 원소가 없도록 정렬하는 방식임
- 평균적으로 O(NlogN)의 시간복잡도를 갖고 입력 데이터가 역순의 데이터가 들어왔을 때 O(N^2)이 되는 최악의 경우도 있음
- 가장 많이 사용되는 정렬법이지만 불안정적인 제자리 정렬 알고리즘이며 입력 데이터에 대해 민감하다는 단점을 가짐. 그래서 퀵정렬의 성능을 향상시키는 방법으로 부분 리스트의 크기가 일정 크기 이하로 작아지면 almost sorted가 되므로 삽입 정렬을 수행하는 작은 부분화일 방법과 정렬되거나 역순으로 데이터가 들어올 경우 정렬을 못할 수도 있는 것을 막고자 중간 값 분할 방법이 존재함


<br>
### 합병정렬(Merge Sort)
- 퀵 정렬과 마찬가지로 divide and conquer방식의 알고리즘으로 전체 배열을 절반으로 나누고 그 데이터를 또 반으로 나눠 가장 작은 단위로 나눈다음 병합하면서 정렬하는 방식임
- 분할하는 과정에서 logN만큼의 시간이 소요되고 병합을 하게되면 최종적으로 O(NlogN)만큼의 시간 복잡도를 갖으며 랜덤이거나 역순, 정렬된 데이터에 대해 민감도가 전혀 없어 모든 경우의 시간 복잡도가 O(NlogN)이 됨
- 방식이 간단하고 안정성이 있으며 성능이 상당히 좋은 방법이지만, 입력 데이터만큼의 추가적인 메모리 공간이 필요하다는 큰 단점이 존재


<br>
### 힙정렬(Heap Sort)
- 힙은 힙 조건을 만족하는 완전 이진트리로 힙 조건은 각 노드의 값이 자식 노드의 값보다 커야 함. 힙정렬은 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법으로 힙의 루트를 가장 마지막 노드의 수와 교환함으로써 루트에 새로 저장된 수로 인해 위배된 힙 조건을 해결해 조건을 만족시키고 힙 크기를 1로 줄이면서 루트를 출력시킴. 이러한 과정을 반복하여 나머지 원소를 정렬
- 퀵정렬보다 느린 O(NlogN)이지만 추가적인 메모리를 요구하지 않고 입력 데이터에 민감하지 않아 항상 O(NlogN)을 보장한다는 점에서 장점임. 하지만 불안정하다는 단점을 보유


<br>
## 분포기반 정렬 알고리즘
### 계수정렬(Counting Sort)
- 입력 키가 어떤 범위에 있다는 것을 알고 있을 때에만 적용 가능한 알고리즘으로 요소 값들끼리 서로 비교를 하지 않음. 배열 내에 원소 값들의 개수를 저장하는 카운팅 배열을 만들어 개수를 세어 누적합을 이용하는 방식을 사용함
- 비교기반 정렬 알고리즘에서 가장 빠른 속도인 퀵, 힙, 합병정렬의 O(NlogN)의 시간 복잡도보다 더 빠른 O(N)으로 안정적인 알고리즘. 하지만 카운팅 배열을 만들어야 하는 기억장소가 필요함


<br>
### 기수정렬(Radix Sort)
- 전체 키를 여러 자리로 나누어 각 자리마다 계수정렬과 같은 안정적인 정렬 알고리즘을 적용하여 정렬하는 알고리즘
- d자리수의 숫자들에 대해 계수 정렬을 정렬할 때 각 자리수마다 O(N)시간이 걸리므로 전체는 O(dN)의 시간이 걸리지만 d를 상수 취급해 O(N)으로 여겨짐
- 비교기반 정렬 알고리즘들에 비해 빠른 속도를 가진 것이 장점이지만, 전체 데이터의 개수만큼 기억장소와 진법 크기만큼의 기억장소가 추가적으로 필요하고 키가 몇 자리 수인지 이미 알고 있어야 한다는 조건이 있음
